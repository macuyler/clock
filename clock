#!/usr/bin/env python3

"""This is a work timing script that is designed to automate tracking my hours for work."""

import sys
import time
from datetime import datetime, timedelta
from pathlib import Path


def config() -> str:
    """Read the configuration file at ~/.clock.conf"""

    file_path = ''

    try:
        with open(f'{Path.home()}/.clock.conf', 'r', encoding='utf-8') as conf_file:
            configuration = conf_file.read()
        file_path = configuration.strip()
    except FileNotFoundError:
        print('\n * No config file found!')
        print('   Create ~/.clock.conf and put the path to your clock log file inside it.')
        print('   See the README.md for more details.\n')
        sys.exit(0)

    return file_path


def get_date() -> str:
    """Get the current formatted date."""

    p_date = str(datetime.date(datetime.now())).split('-')
    return f'{p_date[1]}/{p_date[2]}/{p_date[0][2::]}'


def parse_date(line: str) -> datetime:
    """Parse the date from a logged line."""

    date_string = line.split(':')[0].strip()
    return datetime.strptime(date_string, "%m/%d/%y")


def get_hours(log_path: str) -> list[str]:
    """Read the lines of a log file."""

    hours = []

    try:
        with open(log_path, 'r', encoding='utf-8') as log_file:
            hours = log_file.readlines()
    except FileNotFoundError:
        print('\n * Invalid file path!')
        print('   Make sure you are using an absolute path, ie. /home/user/ instead of ~/')
        print('   See the README.md for more details.\n')
        sys.exit(0)

    return hours


def get_week(hours: list[str], week_hours: list[str]) -> list[str]:
    """Recursively parse the last week in the logs."""

    i = len(hours) - 1
    line = hours[i]
    hours.pop(i)
    week_hours.insert(0, line)
    if 'Week' in line:
        return week_hours

    return get_week(hours, week_hours)


def get_total(week_hours: list[str]) -> str:
    """Calculate and format the total time worked in a week."""

    total_hours = 0
    total_minutes = 0
    week_hours = week_hours[1::]

    for day in week_hours:
        hours = day.split(': ')[1].replace('HR', '').strip().split(':')
        total_hours += int(hours[0])
        total_minutes += int(hours[1])

    total_hours += int(total_minutes / 60)
    total_minutes = total_minutes % 60

    if total_minutes < 10:
        total_minutes = f'0{total_minutes}'

    return f'{total_hours}:{total_minutes}HR'


def get_week_num(prev_week: str) -> str:
    """Calculate the current week number."""

    return str(int(prev_week.replace('Week ', '').replace(':', '').strip()) + 1)


def backfill(week_hours: list[str]) -> list[str]:
    """Fill in missing dates with 00s."""

    a_day = timedelta(days=1)
    filled_week_hours = week_hours[0:1]

    for i, today in enumerate(week_hours):
        if i > 1:
            yesterday = week_hours[i - 1]
            prev = parse_date(yesterday)
            current = parse_date(today)
            filled_week_hours.append(yesterday)

            while prev + a_day != current:
                prev += a_day
                filled_week_hours.append(f'\t{prev.strftime("%m/%d/%y")}: 0:00HR\n')

    filled_week_hours.append(week_hours[len(week_hours) - 1])

    return filled_week_hours


def check_weekend(week_hours: list[str]) -> list[str]:
    """Calculate the total and start a new week after 7 days."""

    week_hours = backfill(week_hours)
    if len(week_hours) > 8:
        last_week = []
        new_week = []

        for i, line in enumerate(week_hours):
            if i <= 7:
                last_week.append(line)
            else:
                new_week.append(line)

        total = get_total(last_week)
        week_num = get_week_num(last_week[0])
        weekend = ['\n', f'\tTotal = {total}\n', f'Week {week_num}:\n']
        week_hours = last_week + weekend + new_week

    return week_hours


def write_changes(log_path: str, lines: list[str]):
    """Write the given lines to the log file."""

    output = ''.join(lines)

    try:
        with open(log_path, 'w', encoding='utf-8') as log_file:
            log_file.write(output)
    except FileNotFoundError:
        print('\n * Invalid file path!')
        print('   Make sure you are using an absolute path, ie. /home/user/ instead of ~/')
        print('   See the README.md for more details.\n')
        print(" * Don't lose these:")
        print(f'\n{output}\n')
        sys.exit(0)


def handle_input(i: str, start: time):
    """Parse and handle user input."""

    if i.lower() == 't':
        diff = int(time.time() - start)
        minutes = int(diff / 60)
        hours = int(minutes / 60)
        minutes %= 60
        print(f'Current Running Time: {hours}:{minutes}')


def run_time() -> int:
    """Start a timer and run an infinite loop."""

    print('\n\n********************************\n')
    print('\n---- You have clocked in... ----\n')
    print('\n * Enter [t] to show current time')
    print(' * Enter [q] to end\n')
    print('********************************\n')

    start = time.time()

    i = ''
    while i.lower() != 'q':
        i = input('> ')
        handle_input(i, start)

    end = time.time()
    seconds = int(end - start)
    return seconds


def add_time(seconds: int, week_hours: list[str]):
    """Merge the time worked into the week_hours list."""

    total_minutes = int(seconds / 60)
    total_hours = int(total_minutes / 60)
    total_minutes %= 60

    new_line = f'\t{get_date()}: {total_hours}:{total_minutes}HR\n'
    current_date_lines = ['', new_line] # get_total removes the first value
    duplicate_indexes = []

    print(f'\n\nClocked for = {total_hours}:{total_minutes}HR\n')

    for i, line in enumerate(week_hours):
        if get_date() in line:
            current_date_lines.append(line)
            duplicate_indexes.append(i)

    for j, i in enumerate(duplicate_indexes):
        week_hours.pop(i - j)

    new_time = get_total(current_date_lines)
    new_line = f'\t{get_date()}: {new_time}\n'
    week_hours.append(new_line)


def main():
    """Run the clock process."""

    log_path = config()
    all_hours = get_hours(log_path)
    week_hours = get_week(all_hours, [])
    seconds = run_time()
    add_time(seconds, week_hours)
    checked_hours = check_weekend(week_hours)
    new_hours = all_hours + checked_hours
    write_changes(log_path, new_hours)


if __name__ == '__main__':
    main()
